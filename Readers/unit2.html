<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>Unit 2 - Types in Functional Programming</title>
        <style>
</style>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        
        <script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
        
    </head>
    <body class="vscode-body vscode-light">
        <h1 id="unit-2---types-in-functional-programming">Unit 2 - Types in Functional Programming</h1>
<p>In Unit 1 we introduced an untyped formulation of lambda calculus, which is the foundational model of functional programming. We then proceeded to translate the constructs of lambda calculus into the functional programming language F# without focusing on types. In this chapter we introduce a statically typed version of lambda calculus and then we show how its usage in F#. We then proceed to define basic data structures in F#</p>
<h2 id="typed-lambda-calculus">Typed Lambda Calculus</h2>
<p>In this section we present the typing rules for lambda-calculus. As we have seen in the previous unit, lambda-calculus is made of the following main components: variables, abstractions, and function applications.</p>
<p>In this context we assume that we have a set of declarations that contains the type definitions encountered so far, and we call this <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span>. Moreover, we to say that a term <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> in the language has type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>, we write <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>:</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">x : t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span></p>
<p>When we encounter a variable <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>, we simply return its type looked up in the declaration table:</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>h</mi><mi>e</mi><mi>c</mi><mi>k</mi><mo stretchy="false">(</mo><mi>v</mi><mo separator="true">,</mo><mi>T</mi><mo stretchy="false">)</mo><mo>⇒</mo><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">[</mo><mi>v</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>T</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">check(v,T) \Rightarrow (T[v],T)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mclose">)</span></span></span></span></p>
<p>This means that we look up in the declarations the variable <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>. If this exists then the look-up will return its type. If the variable does not exist then the typechecking fails.</p>
<p>When we encounter an abstraction, we simply add the type of its parameter (remember that it is alway one) to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span>, and then we proceed to typecheck the function body:</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>h</mi><mi>e</mi><mi>c</mi><mi>k</mi><mo stretchy="false">(</mo><mtext>fun</mtext><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><msub><mi>t</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>→</mo><mi>e</mi><mo stretchy="false">)</mo><mo>⇒</mo><mo stretchy="false">(</mo><msub><mi>t</mi><mn>1</mn></msub><mo>→</mo><msub><mi>t</mi><mn>2</mn></msub><mo separator="true">,</mo><mi>T</mi><mo stretchy="false">)</mo><mtext> when </mtext><mi>c</mi><mi>h</mi><mi>e</mi><mi>c</mi><mi>k</mi><mo stretchy="false">(</mo><mi>e</mi><mo separator="true">,</mo><mi>T</mi><mo stretchy="false">[</mo><mi>x</mi><mo>:</mo><mo>=</mo><msub><mi>t</mi><mn>1</mn></msub><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo>⇒</mo><mo stretchy="false">(</mo><msub><mi>t</mi><mn>2</mn></msub><mo separator="true">,</mo><mi>T</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">check(\text{fun} (x : t_1) \rightarrow e) \Rightarrow (t_1 \rightarrow t_2,T) \text{ when } check(e,T[x := t_1]) \Rightarrow (t_2,T)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mopen">(</span><span class="mord text"><span class="mord">fun</span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">e</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mclose">)</span><span class="mord text"><span class="mord"> when </span></span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mopen">(</span><span class="mord mathdefault">e</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mclose">)</span></span></span></span></p>
<p>Finally, when we encounter a function application, we simply make sure that the input of the function has the same type of its parameter:</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>h</mi><mi>e</mi><mi>c</mi><mi>k</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>f</mi><mtext>  </mtext><mi>x</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>T</mi><mo stretchy="false">)</mo><mo>⇒</mo><mo stretchy="false">(</mo><msub><mi>t</mi><mn>2</mn></msub><mo separator="true">,</mo><mi>T</mi><mo stretchy="false">)</mo><mtext> when </mtext><mi>c</mi><mi>h</mi><mi>e</mi><mi>c</mi><mi>k</mi><mo stretchy="false">(</mo><mi>f</mi><mo separator="true">,</mo><mi>T</mi><mo stretchy="false">)</mo><mo>⇒</mo><mo stretchy="false">(</mo><msub><mi>t</mi><mn>1</mn></msub><mo>→</mo><msub><mi>t</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mtext> and </mtext><mi>c</mi><mi>h</mi><mi>e</mi><mi>c</mi><mi>k</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>T</mi><mo stretchy="false">)</mo><mo>⇒</mo><msub><mi>t</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">check((f \; x),T) \Rightarrow (t_2,T) \text{ when } check(f,T) \Rightarrow (t_1 \rightarrow t_2) \text{ and } check(x,T) \Rightarrow t_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mclose">)</span><span class="mord text"><span class="mord"> when </span></span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord text"><span class="mord"> and </span></span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<h2 id="type-annotation-in-f">Type Annotation in F#</h2>
<p>Type checking in F# follows the same basics rules defined in the previous section. Type annotation of bindings can be achieved with the following syntax:</p>
<pre><code><code><div>let (id : type) = expr
</div></code></code></pre>
<p>where <code>id</code> is the identifier used for the binding and <code>type</code> a valid type indentified. Basic types in F# are <code>int</code>, <code>float</code> (double-precision floating-point numbers like <code>double</code> in C#), <code>float32</code> (single-precision floating-point numbers like <code>float</code> in C#), <code>string</code>, ...</p>
<p>For example:</p>
<pre><code class="language-fsharp"><div><span class="hljs-keyword">let</span> (x : float) = <span class="hljs-number">5.25</span>
</div></code></pre>
<p>Note that F# does not perform automatic type conversions like C#, so for example the following code will produce a type error:</p>
<pre><code class="language-fsharp"><div><span class="hljs-keyword">let</span> (x : float) = <span class="hljs-number">5</span>
</div></code></pre>
<p>whereas, the same code in C# would work:</p>
<pre><code class="language-csharp"><div><span class="hljs-keyword">double</span> x = <span class="hljs-number">5</span>;
</div></code></pre>
<p>In order to correctly type the expression above, we use the correct floating-point double-precision literal:</p>
<pre><code class="language-fsharp"><div><span class="hljs-keyword">let</span> (x : float) = <span class="hljs-number">5.0</span>
</div></code></pre>
<p>For this reason, every numerical type has its different corresponding literal in F#. A comprehensive list can be found in <a href="https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/literals">MSDN</a>.</p>
<p>Type conversions can be achieved by using conversion functions, such as <code>int</code>, <code>float</code>, <code>string</code>, ... They are all named after the type you want to convert to. These are especially useful when doing operations between incompatible types. For instance, in C# the expression <code>x / 5.0</code> when <code>x</code> has type <code>int</code> is accepted and typecheck correctly, while in F# it would return a type error because no automatic conversion is performed. For this reason one should use the conversion function <code>int</code> to convert <code>x</code> in a float:</p>
<pre><code class="language-fsharp"><div>(int x) / <span class="hljs-number">5.0</span>
</div></code></pre>
<p>Another important type in F# is <code>unit</code>. This identifies the absence of values and its only value is <code>()</code>. Note that the value of type <code>unit</code>, unlike <code>void</code> in C#, can be normally bound to variables (in C# there is no value corresponding to <code>void</code>). <code>unit</code> can be used when a function takes no arguments or returns nothing.</p>
<p>Arguments of lambda abstractions can be typed analogously:</p>
<pre><code class="language-fsharp"><div><span class="hljs-keyword">let</span> (f : t1 -&gt; t2 -&gt; ... -&gt; tn -&gt; tr) = 
  (<span class="hljs-keyword">fun</span> (arg1 : t1) (arg2 : t2) ... (argn : tn) -&gt; expr) : t1 -&gt; t2 -&gt; ... -&gt; tn -&gt; tr
</div></code></pre>
<p>Notice that, if we do not want to rely on type inference, we must provide the type of the binding as the type of an abstraction, as we are binding a lambda. For example:</p>
<pre><code class="language-fsharp"><div><span class="hljs-keyword">let</span> (add: int -&gt; int -&gt; int) = <span class="hljs-keyword">fun</span> (x : int) (y : int) -&gt; x + y
</div></code></pre>
<p>As seen in Unit 1, an alternative notation to define functions is possible, which becomes with type annotations:</p>
<pre><code class="language-fsharp"><div><span class="hljs-keyword">let</span> f (arg1 : t1) (arg2 : t2) ... (argn : tn) : tr = expr
</div></code></pre>
<p>Thus, for example, the function <code>add</code> can be redefined as:</p>
<pre><code class="language-fsharp"><div><span class="hljs-keyword">let</span> add (x : int) (y : int) : int = x + y
</div></code></pre>
<p>F# supports generic polymorphism, thus we can provide type parameters to functions. This is done by adding an apostrophe before the type name, such as:</p>
<pre><code class="language-fsharp"><div><span class="hljs-keyword">let</span> (stringify : <span class="hljs-symbol">&#x27;a</span> -&gt; string) = <span class="hljs-keyword">fun</span> (x : <span class="hljs-symbol">&#x27;a</span>) -&gt; string x
</div></code></pre>
<p>This means that the function <code>stringify</code> is generic with respect to the type parameter <code>'a</code>. Note that the language distinguishes between non-generic and generic types by checking if they are preceeded by an apostrophe, thus <code>'string</code> denotes a generic type called <code>'string</code> and <code>string</code> (without the apostrophe) is the built-in type for strings.</p>
<p><strong>Example</strong></p>
<p>Complete the type annotations for the following program (the implementation details are hidden for brevity).</p>
<pre><code class="language-fsharp"><div><span class="hljs-keyword">let</span> foo (x : int) (s : string) : int = ...
<span class="hljs-keyword">let</span> (z : ___) = foo <span class="hljs-number">5</span>
</div></code></pre>
<p>Remember that the definition of <code>foo</code> is equivalent to <code>fun (x : int) -&gt; (s : string) -&gt; ...</code>. According to the typing rules of lambda calculus, in order to determine the type of <code>foo</code>, we have to type check the body of the function after adding the parameter to the type declaration. This results in having T = { x := int }. In order to get the full type of this function, we need to recursively type check its body, which is itself another lambda: <code>(s : string) -&gt; ...</code>. Now, since the text says that the body of the function is not provided, we can safely assume that is correctly formed, so that the type checking of the body succeeds and returns <code>int</code>, as provided in the function declaration <code>let foo (x : int) (s : string) : int</code>. According to the second type rule of lambda calculus, this lambda has thus type <code>string -&gt; int</code>. Then the body of <code>fun (x : int) -&gt; (s : string) -&gt; ...</code> has type <code>string -&gt; int</code>, and the full type of the function becomes <code>int -&gt; string -&gt; int</code>.</p>
<p>At this point we can determine the type of the binding in the second line. This binding contains the result of a partial application of <code>foo</code>. According to the third type rule of lambda calculus, we have to make sure that the argument passed in the call matches the type of the parameter in the definition of the function. Since, they are both <code>int</code>, this succeeds. At this point the resulting type is the type of the body of the lambda, i.e. the type of <code>(s : string) -&gt; ...</code>. We have already determined its type above, which is <code>string -&gt; int</code>, which is also the type of the binding <code>z</code>.</p>
<p>You can notice that, when we partially apply a function, the effect is that we remove the type of each argument that is passed from the &quot;arrow&quot; type, and what is left is the resulting type. For instance, the full type of the function <code>foo</code> was <code>int -&gt; string -&gt; int</code> and we passed only one argument in the call, so we remove the <code>int</code> part in the full type and we are left with <code>string -&gt; int</code>. If we passed two arguments in the call, then we would have to remove both <code>int</code> and <code>string</code>, and we would be left with just <code>int</code>.</p>
<h2 id="basic-data-structures-in-f">Basic Data Structures in F#</h2>
<p>F# natively implements complex data structures such as <em>tuples</em> and <em>lists</em>. A tuple is an ordered sequence of non-homogeneous values, such as <code>(3,&quot;Hello world!&quot;,-45.3f)</code>. The type of a tuple is denoted as</p>
<pre><code><code><div>t1 * t2 * ... * tn
</div></code></code></pre>
<p>where <code>t1</code>, <code>t2</code>,..., <code>tn</code> are types. Thus a tuple is the n-ary Cartesian product of values of type <code>t1</code>, <code>t2</code>,..., <code>tn</code>. For example:</p>
<pre><code class="language-fsharp"><div><span class="hljs-keyword">let</span> (t : int * string * float32) = (<span class="hljs-number">3</span>,<span class="hljs-string">&quot;Hello world!&quot;</span>,<span class="hljs-number">-45.3</span>f)
</div></code></pre>
<p>Tuples, of course, can be passed as arguments to functions. In this context, there is a particular application of this which is an alternative to currying. In Unit 1 we saw that in lambda calculus (and also in F#) a function admits one argument only. In order to model the behaviour of functions that operate on more than one argument, we relied on the notion of currying: a function that wants to use two arguments will simply return in its body another lambda that is able to process the second argument and has in its closure the first argument. For instance:</p>
<pre><code class="language-fsharp"><div><span class="hljs-keyword">let</span> add = <span class="hljs-keyword">fun</span> x -&gt; <span class="hljs-keyword">fun</span> y -&gt; x + y
</div></code></pre>
<p>When we call such function with <code>add 3 5</code> we replace <code>x</code> with 3 in its body thus generating <code>fun y -&gt; 3 + y</code>, and then we apply <code>(fun y -&gt; 3 + y) 5</code> thus obtaining <code>3 + 5 = 8</code>. An alternative to this is the <em>uncurried</em> version, where we pass the arguments in a tuple as follows:</p>
<pre><code class="language-fsharp"><div><span class="hljs-keyword">let</span> addUncurried = <span class="hljs-keyword">fun</span> (x,y) -&gt; x + y
</div></code></pre>
<p>Note that the curried and uncurried versions are not interchangable because their type is different. For instance, the type of <code>add</code> is:</p>
<pre><code class="language-fsharp"><div><span class="hljs-keyword">let</span> (add : int -&gt; int -&gt; int) = <span class="hljs-keyword">fun</span> x y -&gt; x + y
</div></code></pre>
<p>while the type of <code>addUncurried</code> is:</p>
<pre><code class="language-fsharp"><div><span class="hljs-keyword">let</span> (addUncurried : int * int -&gt; int) = <span class="hljs-keyword">fun</span> (x,y) -&gt; x + y
</div></code></pre>
<p>Notice that the uncurried version of a function takes both arguments all together, thus partial application is not possible: we can call <code>add 3</code> and this will generate as result <code>fun y -&gt; 3 + y</code>, but we cannot call <code>addUncurried 3</code> because this would mean passing an argument of typ <code>int</code> to a function that expects <code>int * int</code>. We will see further ahead in this course that it is possible to define a generic function that can convert the curried version of a function to the uncurried version, and the opposite.</p>
<h2 id="records">Records</h2>
<p>Recors are finite map of names into values that can optionally define some members. This definition resembles that of Class in a object-oriented language, but there is a profound difference: the fields of a record are by default immutable, meaning that it is not possible to change their values directly. Of course, being a hybrid language, F# allows also to define mutable record fields, but, as said before, we ignore mutability in this course. A record is declared with the following syntax:</p>
<pre><code class="language-fsharp"><div><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">R</span> </span>=
  {
    f1 : t1
    f2 : t2
    ...
    fn : tn
  }
</div></code></pre>
<p>For instance, the following record represents the login information to connect to a server:</p>
<pre><code class="language-fsharp"><div><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">LoginInfo</span> </span>=
  {
    UserName        : string
    Password        : string
    Address         : string
  }
</div></code></pre>
<p>Synce F# is indentation-sensitive, we must place particular care about how we indent the record definition: brackets should be indented with respect to the <code>type</code> keyword, and fields must be indented with respect to brackes. Failing to do so will often result in a compilation error.</p>
<p>Optionally a record can define some methods and properties (members):</p>
<pre><code class="language-fsharp"><div><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">R</span> </span>=
  {
    f1 : t1
    f2 : t2
    ...
    fn : tn
  }
  <span class="hljs-keyword">with</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">member</span> M1(arg1 : t1, arg2 : t2, ..., argn : tn1) : tr1 =
    ...
    <span class="hljs-keyword">member</span> this.M2(arg1 : t1, arg2 : t2, ..., argn : tn2) : tr2 =
    ...
</div></code></pre>
<p>Note that, given the immutable nature of records, their methods must also behave in an immutable way.</p>
<p>A characteristic of F# is that an instance method must always declare the name of the implicit <code>this</code> parameter. This is so because F# does not restrict the name of the implicit parameter to a specific keyword, like <code>this</code> in C#, rather it can be customized, so for example you could call it <code>self</code> or <code>current</code>. Notice that it is possible also to use the curried version of methods with the usual syntax. For instance:</p>
<pre><code class="language-fsharp"><div><span class="hljs-keyword">member</span> this.M2 (arg1 : T1) (arg2 : T2) ... (argn : tn2) : tr2 = ...
</div></code></pre>
<p>Also notice that, in order to define a recursive method, it is not necessary to use the <code>rec</code> keyword as for functions. All members can be recursivelly called without the need of an extra clause.</p>
<p>A record can be instantiated with the following syntax:</p>
<pre><code class="language-fsharp"><div>{ f1 = value1 ; f2 = value2 ; ... ; fn = valuen }
</div></code></pre>
<p>or</p>
<pre><code class="language-fsharp"><div>  {
    f1 = value1
    f2 = value2
    ...
    fn = valuen
  }
</div></code></pre>
<p>It is immediately evident that, for records with a high number of fields, this syntax becomes quite cumbersome. For this reason, it is preferable to define a static method <code>Create</code>, which is equivalent to a constructor in an objec-oriented language, to instantiate a record:</p>
<pre><code class="language-fsharp"><div><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">R</span> </span>=
  {
    f1 : t1
    f2 : t2
    ...
    fn : tn
  }
  <span class="hljs-keyword">with</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">member</span> Create(arg1 : t1, arg2 : t2, ..., argn : tn) : R =
      {
        f1 = arg1
        f2 = arg2
        ...
        fn = argn
      }
</div></code></pre>
<h2 id="record-copy-and-update">Record copy and update</h2>
<p>As said above, records are immutable, so it is not possible to directly update their fields. In order obtain the same effect of a field update, we must create a new record where all the values of the fields that are left untouched by the update are initialized by reading the corresponding values in the original record, and all the updated fields are initialized with the new value. For instance, let us consider the <code>LoginInfo</code> above, and suppose that you need to change the server address, that would require the following steps:</p>
<pre><code class="language-fsharp"><div><span class="hljs-keyword">let</span> oldLogin = 
  { 
    UserName = <span class="hljs-string">&quot;awesomeuser@aw.us&quot;</span>  
    Password = <span class="hljs-string">&quot;supersecretkey&quot;</span>
    Address = <span class="hljs-string">&quot;155.34.21.105&quot;</span> }
<span class="hljs-keyword">let</span> newLogin = 
  { 
    UserName = oldLogin.UserName
    Password = oldLogin.Password
    Address = <span class="hljs-string">&quot;165.40.69.69&quot;</span> 
  } 
</div></code></pre>
<p>You can immediately notice that this operation becomes quite cumbersome when updating just a small number of fields of records with many fields. For this reason, the following shortcut is available:</p>
<pre><code class="language-fsharp"><div><span class="hljs-keyword">let</span> newRecord = 
  { oldRecord <span class="hljs-keyword">with</span> 
      f1 = v1
      f2 = v2 
      ... 
      fk = vk 
  }
</div></code></pre>
<p>This will make a copy of oldRecord and initialize the fields <code>f1</code>,<code>f2</code>, ..., <code>fk</code> with the specified values, while the others simply contain the values from <code>oldRecord</code>. The concrete example above becomes then :</p>
<pre><code class="language-fsharp"><div><span class="hljs-keyword">let</span> oldLogin = 
  { 
    UserName = <span class="hljs-string">&quot;awesomeuser@aw.us&quot;</span>
    Password = <span class="hljs-string">&quot;supersecretkey&quot;</span>
    Address = <span class="hljs-string">&quot;155.34.21.105&quot;</span>
  }
<span class="hljs-keyword">let</span> newLogin =
  {oldLogin <span class="hljs-keyword">with</span>
      Address = <span class="hljs-string">&quot;165.40.69.69&quot;</span>
  }
</div></code></pre>
<h2 id="structural-equality">Structural Equality</h2>
<p>Since the semantics of functional programming languages do not rely on a shared memory, they cannot perform equality comparisons based on references like we are used to in imperative programming languages. By default, all data structures in F#, including newly-defined records, are compared by value and not by reference. This means that, using the <code>=</code> operator, F# will recursively check the components of the data structures and compare their value.
For instance, consider the tuples <code>let t1 = (1,3,5)</code> and <code>let t2 = (1,3,-5)</code>: in this case F# will compare the first component of <code>t1</code> with the first component of <code>t2</code>, which passes the test. Then it will compare the second component of <code>t1</code> with the second of <code>t2</code>, passing the test as well. Finally, the third components are compared, which returns <code>false</code> because of course 5 and -5 are different. The same is done for the fields of a record. Notice that, since tuple components and record fields can contain complex data structures, this procedure is recursive, i.e. if the component/field is a tuple or a record then the structural equality is recursively applied on their values. For instance, the value in <code>test</code> in the following code is <code>true</code>:</p>
<pre><code class="language-fsharp"><div><span class="hljs-keyword">let</span> l1 = 
  { 
    UserName = <span class="hljs-string">&quot;awesomeuser@aw.us&quot;</span> 
    Password = <span class="hljs-string">&quot;supersecretkey&quot;</span>
    Address = <span class="hljs-string">&quot;155.34.21.105&quot;</span> 
  }
<span class="hljs-keyword">let</span> l2 = 
  { 
    UserName = <span class="hljs-string">&quot;awesomeuser@aw.us&quot;</span>
    Password = <span class="hljs-string">&quot;supersecretkey&quot;</span>
    Address = <span class="hljs-string">&quot;155.34.21.105&quot;</span>
  }
<span class="hljs-keyword">let</span> test = l1 = l2
</div></code></pre>
<h2 id="recursive-type-definitions">Recursive type definitions</h2>
<p>Like for functions, types are normally visible if they are declared before the line in which we are trying to use them. For instance the following code will produce a type error:</p>
<pre><code class="language-fsharp"><div>
<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">A</span> </span>= 
  {
    X : int
    Y : B <span class="hljs-comment">//this generate a compilation error</span>
  }

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">B</span> </span>=
  {
    X : A
    Y : string
  }
</div></code></pre>
<p>In the definition of <code>A</code> we are trying to use a field of type <code>B</code> that is declared below. What we want to achieve is a recursive type definition. This can be expressed in F# by replacing the keyword <code>type</code> in <code>B</code> with <code>and</code> :</p>
<pre><code class="language-fsharp"><div><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">A</span> </span>= 
  {
    X : int
    Y : B
  }

<span class="hljs-keyword">and</span> B =
  {
    X : A
    Y : string
  }
</div></code></pre>
<p>All types that are declared with the <code>and</code> keyword in place of <code>type</code> are visible before the line of their declaration.</p>
<h2 id="case-study-tanks-and-guns">Case Study: Tanks and Guns</h2>
<p>In this section we present a small case study to show the usage of records. Let us assume that we want to model an entity <code>Tank</code> defined by name, speed, weapon, armor, and health. Each tank weapon is a gun defined by name, penetration power, and damage. A tank can shoot a shell at another tank with its gun, with the following effect: if the gun penetration is higher than the target armour then the health of the target is reduced by the weapon damage. Otherwise the amount of armour is decreased by the gun penetration. Let us first define the records for guns and tanks:</p>
<pre><code class="language-fsharp"><div><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Gun</span> </span>=
  {
    Name              : string
    Penetration       : float
    Damage            : float
  }
  <span class="hljs-keyword">with</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">member</span> Create(name: string, penetration : float, damage : float) =
      { Name = name; Penetration = penetration; Damage = damage }

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Tank</span> </span>=
  {
    Name    : string
    Weapon  : Gun
    Armor   : float
    Health  : float
  }
  <span class="hljs-keyword">with</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">member</span> Create(name :string, weapon : Gun, armor : float, health : float) =
      {
        Name = name
        Weapon = weapon
        Armor = armor
        Health = health
      }
</div></code></pre>
<p>and let us define some gun and tank models:</p>
<pre><code class="language-fsharp"><div><span class="hljs-keyword">let</span> kwk36 = Gun.Create(<span class="hljs-string">&quot;88mm KwK 36&quot;</span>, <span class="hljs-number">150.0</span>, <span class="hljs-number">90.0</span>)
<span class="hljs-keyword">let</span> f32 = Gun.Create(<span class="hljs-string">&quot;76mm F-32&quot;</span>, <span class="hljs-number">70.0</span>, <span class="hljs-number">60.0</span>)
<span class="hljs-keyword">let</span> kwk40short = Gun.Create(<span class="hljs-string">&quot;75mm kwk 37&quot;</span>, <span class="hljs-number">35.5</span>, <span class="hljs-number">55.5</span>)
<span class="hljs-keyword">let</span> kwk40Long = Gun.Create(<span class="hljs-string">&quot;75mm KwK 40&quot;</span>, <span class="hljs-number">99.5</span>, <span class="hljs-number">55.5</span>)
<span class="hljs-keyword">let</span> m1a1 = Gun.Create(<span class="hljs-string">&quot;76mm M1A1&quot;</span>, <span class="hljs-number">99.0</span>, <span class="hljs-number">60.0</span>)
<span class="hljs-keyword">let</span> tiger = Tank.Create(<span class="hljs-string">&quot;Pz.Kpfw. VI Tiger Ausf. E&quot;</span>, kwk36, <span class="hljs-number">340.0</span>, <span class="hljs-number">800.0</span>)
<span class="hljs-keyword">let</span> t34 = Tank.Create(<span class="hljs-string">&quot;T-34/76&quot;</span>, f32, <span class="hljs-number">200.0</span>, <span class="hljs-number">400.0</span>)
<span class="hljs-keyword">let</span> p4f = Tank.Create(<span class="hljs-string">&quot;Pz.Kpfw. IV&quot;</span>, kwk40short, <span class="hljs-number">130.0</span>, <span class="hljs-number">350.0</span>)
<span class="hljs-keyword">let</span> p4g = Tank.Create(<span class="hljs-string">&quot;Pz.Kpfw. IV&quot;</span>, kwk40Long, <span class="hljs-number">130.0</span>, <span class="hljs-number">350.0</span>)
<span class="hljs-keyword">let</span> shermanE8 = Tank.Create(<span class="hljs-string">&quot;M4A3 Sherman E8&quot;</span>, m1a1, <span class="hljs-number">220.0</span>, <span class="hljs-number">450.0</span>)
</div></code></pre>
<p>Now let us implement the logic of the combat as a method of <code>Tank</code>. This method will take as explicit parameter the opponent tank.</p>
<pre><code class="language-fsharp"><div><span class="hljs-keyword">member</span> this.Shoot (tank : Tank) = ... 
</div></code></pre>
<p>This method will have to check the weapon penetration of <code>this</code> against the <code>Armor</code> of <code>tank</code>. If it is higher than we print a message on the status and we update the health of <code>tank</code>. If it is lower than the target armour we reduce the armour value of <code>tank</code>.</p>
<pre><code class="language-fsharp"><div><span class="hljs-keyword">member</span> this.Shoot(tank : Tank) =
  <span class="hljs-keyword">if</span> this.Weapon.Penetration &gt; tank.Armor <span class="hljs-keyword">then</span>
    printfn <span class="hljs-string">&quot;%s shoots %s with %s causing %f damage --&gt; HEALTH: %f&quot;</span> 
      this.Name 
      tank.Name 
      this.Weapon.Name 
      this.Weapon.Damage 
      tank.Health 
    { tank <span class="hljs-keyword">with</span> Health = tank.Health - this.Weapon.Damage }
  <span class="hljs-keyword">else</span>
    printfn <span class="hljs-string">&quot;%s shoots %s with %s reducing armour by %f --&gt; ARMOUR: %f&quot;</span> 
      this.Name 
      tank.Name 
      this.Weapon.Name 
      this.Weapon.Penetration
      tank.Armor
    { tank <span class="hljs-keyword">with</span> Armor = tank.Armor - this.Weapon.Penetration }
</div></code></pre>
<p>Now let us make two tanks fight. We do so by implementing a function that takes two tanks and repetedly calls the <code>Shoot</code> method in turn until one of the two tanks is destroyed. This function will be recursive, since it must repeat the shooting phase an indefinite number of times. The base case of the recursion is when one of the two tanks is destroyed. Ohterwise we must call the function again with the updated tanks after they shoot each other:</p>
<pre><code class="language-fsharp"><div><span class="hljs-keyword">let</span> <span class="hljs-keyword">rec</span> fight (t1 : Tank) (t2 : Tank) =
  <span class="hljs-keyword">if</span> t1.Health &lt;= <span class="hljs-number">0.0</span> <span class="hljs-keyword">then</span>
    printfn <span class="hljs-string">&quot;%s: KABOOOM!!! %s wins&quot;</span> t1.Name t2.Name
    t1,t2
  <span class="hljs-keyword">elif</span> t2.Health &lt;= <span class="hljs-number">0.0</span> <span class="hljs-keyword">then</span>
    printfn <span class="hljs-string">&quot;%s: KABOOOM!!! %s wins&quot;</span> t2.Name t1.Name
    t1,t2
  <span class="hljs-keyword">else</span>
    <span class="hljs-keyword">let</span> t2 = t1.Shoot t2
    <span class="hljs-keyword">let</span> t1 = t2.Shoot t1
    fight t1 t2
</div></code></pre>
<p>Now let us assume that we want to retrofit a specific tank with a better gun. The retrofit takes a gun and tries to mount it on a tank. If the tank model matches the retrofitting model then the new gun is applied, otherwise the tank is returned as it is. In order to do this, we have to exploit the structural equality provided by F#: we compare the current tank with the retrofitting model, and if they are structurally equal then we returned a new tank with the modified gun, otherwise we return the tank as it is.</p>
<pre><code class="language-fsharp"><div><span class="hljs-keyword">member</span> this.Retrofit (gun : Gun, tank : Tank) =
  <span class="hljs-keyword">if</span> this = tank <span class="hljs-keyword">then</span>
    {this <span class="hljs-keyword">with</span>
        Weapon = gun}
  <span class="hljs-keyword">else</span>
    this
</div></code></pre>
<p>Structural equality also offers the possibility of refactoring our code. Notice that in <code>fight</code> the first two cases of the <code>if</code> are doing the same thing. We can thus define a function <strong>nested</strong> into <code>fight</code> that prints the message in both cases and returns <code>t1</code> and <code>t2</code>. This function will be defined as</p>
<pre><code class="language-fsharp"><div><span class="hljs-keyword">let</span> outcome (loser : Tank) (winner : Tank) = ...
</div></code></pre>
<p>This function will be called as <code>outcome t1 t2</code> in the first case of the <code>if</code> and as <code>outcome t2 t1</code> in the second case. Notice that, since the argument in the two calls are swapped, in the body of <code>outcome</code> we cannot simply return <code>loser,winner</code> because that would sometimes swap the returned tanks. We can check if <code>loser</code> is indeed <code>t1</code> and, if not, return <code>t2,t1</code> instead of <code>t1,t2</code> (by convention we are returning the <code>loser</code> tank in the first position of the tuple).</p>
<pre><code class="language-fsharp"><div><span class="hljs-keyword">let</span> outcome loser winner =
  printfn <span class="hljs-string">&quot;%s: KABOOOM!!! %s wins&quot;</span> loser.Name winner.Name
  <span class="hljs-keyword">if</span> t1 = loser <span class="hljs-keyword">then</span>
    t1,t2
  <span class="hljs-keyword">else</span>
    t2,t1
</div></code></pre>
<p>With this refactoring, <code>fight</code> becomes:</p>
<pre><code class="language-fsharp"><div><span class="hljs-keyword">let</span> <span class="hljs-keyword">rec</span> fight (t1 : Tank) (t2 : Tank) =
  <span class="hljs-keyword">let</span> outcome (loser : Tank) (winner : Tank) =
    printfn <span class="hljs-string">&quot;%s: KABOOOM!!! %s wins&quot;</span> loser.Name winner.Name
    <span class="hljs-keyword">if</span> t1 = loser <span class="hljs-keyword">then</span>
      t1,t2
    <span class="hljs-keyword">else</span>
      t2,t1
  <span class="hljs-keyword">if</span> t1.Health &lt;= <span class="hljs-number">0.0</span> <span class="hljs-keyword">then</span>
    outcome t1 t2
  <span class="hljs-keyword">elif</span> t2.Health &lt;= <span class="hljs-number">0.0</span> <span class="hljs-keyword">then</span> 
    outcome t2 t1
  <span class="hljs-keyword">else</span>
    <span class="hljs-keyword">let</span> t2 = t1.Shoot t2
    <span class="hljs-keyword">let</span> t1 = t2.Shoot t1
    fight t1 t2
</div></code></pre>
<h2 id="inheritance-via-record-nesting">Inheritance via record nesting</h2>
<p>Inheritance is an important feature of object-oriented programming that allows, among other things, to recycle the code and the definition of existing classes and, at the same time, to enrich them with additional functionalities. F# records cannot be inherited, but it is possible to achieve an analogous result by nesting them. Consider again the record <code>Tank</code> used above, and suppose that we want to define a new kind of tank with more than one weapon. This would be expressed in C# as <code>Tank2Weapons : Tank</code>. In F# we can define a new record <code>Tank2Weapons</code> that has a field of type <code>Tank</code> containing the base record <code>Tank</code>. This new tank will have an additional field defining the secondary gun and a new way of shooting: it will first shoot the main gun of the tank and then shoot the secondary gun.</p>
<pre><code class="language-fsharp"><div><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Tank2Weapons</span> </span>=
  {
    SecondaryWeapon   : Gun
    Base              : Tank
  }
  <span class="hljs-keyword">with</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">member</span> Create (weapon : Gun) (tank : Tank) =
      {
        SecondaryWeapon = weapon
        Base = tank
      }
</div></code></pre>
<p>Now let us refactor the <code>Shoot</code> function and let us define it in <code>Gun</code> instead of <code>Tank</code>, so that it becomes:</p>
<pre><code class="language-fsharp"><div><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Gun</span> </span>=
  {
    Name              : string
    Penetration       : float
    Damage            : float
  }
  <span class="hljs-keyword">with</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">member</span> Create(name: string, penetration : float, damage : float) =
      { Name = name; Penetration = penetration; Damage = damage }
    <span class="hljs-keyword">member</span> this.Shoot(tank : Tank) =
      <span class="hljs-keyword">if</span> this.Penetration &gt; tank.Armor <span class="hljs-keyword">then</span>
        printfn <span class="hljs-string">&quot;%s shoots %s with %s causing %f damage --&gt; HEALTH: %f&quot;</span> 
          this.Name 
          tank.Name 
          this.Name 
          this.Damage 
          tank.Health 
        { tank <span class="hljs-keyword">with</span> Health = tank.Health - this.Damage }
      <span class="hljs-keyword">else</span>
        printfn <span class="hljs-string">&quot;%s shoots %s with %s reducing armour by %f --&gt; ARMOUR: %f&quot;</span> 
          this.Name 
          tank.Name 
          this.Name 
          this.Penetration
          tank.Armor
        { tank <span class="hljs-keyword">with</span> Armor = tank.Armor - this.Penetration }
</div></code></pre>
<p>and let us also redefine <code>fight</code>  as member of both <code>Tank</code> and <code>Tank2Weapons</code>:</p>
<pre><code class="language-fsharp"><div><span class="hljs-comment">//Fight in Tank</span>
<span class="hljs-keyword">member</span> this.Fight(tank : Tank) =
  <span class="hljs-keyword">let</span> outcome loser winner =
    printfn <span class="hljs-string">&quot;%s: KABOOOM!!! %s wins&quot;</span> loser.Name winner.Name
    <span class="hljs-keyword">if</span> this = loser <span class="hljs-keyword">then</span>
      this,tank
    <span class="hljs-keyword">else</span>
      tank,this
  <span class="hljs-keyword">if</span> this.Health &lt;= <span class="hljs-number">0.0</span> <span class="hljs-keyword">then</span>
    outcome this tank
  <span class="hljs-keyword">elif</span> tank.Health &lt;= <span class="hljs-number">0.0</span> <span class="hljs-keyword">then</span> 
    outcome tank this
  <span class="hljs-keyword">else</span>
    <span class="hljs-keyword">let</span> t2 = this.Weapon.Shoot tank
    <span class="hljs-keyword">let</span> t1 = tank.Weapon.Shoot this
    t1.Fight t2
</div></code></pre>
<p>The version of <code>Fight</code> in <code>Tank2Weapons</code> will first shoot the base weapon of the current tank. This will return an updated copy of <code>Base</code> of the other tank, which must replace the current value in the <code>Base</code> field. Then it will shoot the secondary weapon thus obtaining another copy of <code>Base</code> that must replace the old value again. The same operations are performed for the second tank.</p>
<pre><code class="language-fsharp"><div><span class="hljs-comment">//Fight in Tank2Weapons</span>
<span class="hljs-keyword">member</span> this.Fight(tank : Tank2Weapons) =
  <span class="hljs-keyword">let</span> outcome loser winner =
    printfn <span class="hljs-string">&quot;%s: KABOOOM!!! %s wins&quot;</span> loser.Base.Name winner.Base.Name
    <span class="hljs-keyword">if</span> this = loser <span class="hljs-keyword">then</span>
      this,tank
    <span class="hljs-keyword">else</span>
      tank,this
  <span class="hljs-keyword">if</span> this.Base.Health &lt;= <span class="hljs-number">0.0</span> <span class="hljs-keyword">then</span>
    outcome this tank
  <span class="hljs-keyword">elif</span> tank.Base.Health &lt;= <span class="hljs-number">0.0</span> <span class="hljs-keyword">then</span> 
    outcome tank this
  <span class="hljs-keyword">else</span>
    <span class="hljs-keyword">let</span> t2 = { tank <span class="hljs-keyword">with</span> Base = this.Base.Weapon.Shoot tank.Base }
    <span class="hljs-keyword">let</span> t2 = { t2 <span class="hljs-keyword">with</span> Base = this.SecondaryWeapon.Shoot t2.Base }
    <span class="hljs-keyword">let</span> t1 = { this <span class="hljs-keyword">with</span> Base = tank.Base.Weapon.Shoot this.Base }
    <span class="hljs-keyword">let</span> t1 = { t1 <span class="hljs-keyword">with</span> Base = tank.SecondaryWeapon.Shoot tank.Base }
    t1.Fight t2
</div></code></pre>
<p>The attentive reader will notice that now we have a design problem: we can let <code>Tank</code> fight another <code>Tank</code> and <code>Tank2Weapons</code> fight <code>Tank2Weapons</code> but we cannot mix them up (as it would make sense). This problem can be solved by using polymorphism, thus by defining a function that accepts a <code>TankKind</code> that can be either a <code>Tank</code> or a <code>Tank2Weapons</code>, or function records, but we will explain these topics further ahead.</p>
<h1 id="exercises">Exercises</h1>
<h2 id="exercise-1">Exercise 1</h2>
<p>Model a point in the space as a record <code>Point2D</code> containing a field <code>Position</code>, which is a tuple of type <code>float * float</code>. Define two different constructor methods for this point: the first creates a point given 2 coordinates <code>x</code> and <code>y</code> taken as input. The second creates a random point whose coordinates are between two parameters <code>min</code> and <code>max</code> taken as input. In order to generate a random number you can open <code>System</code> and instantiate as global binding an instance of <code>Random</code> class:</p>
<pre><code class="language-fsharp"><div><span class="hljs-keyword">let</span> r = Random()
</div></code></pre>
<p>Then you can use <code>r.NextDouble()</code> to create a random floating-point number between 0.0 and 1.0 and rescale it in the interval that you need.</p>
<h2 id="exercise-2">Exercise 2</h2>
<p>Extend <code>Point2D</code> with two properties to read the first and second coordinate, and a method to compute the distance between two points. Given a point <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x_1,y_1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x_2,y_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> its distance is given by  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>−</mo><msub><mi>x</mi><mn>2</mn></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>+</mo><mo stretchy="false">(</mo><msub><mi>y</mi><mn>1</mn></msub><mo>−</mo><msub><mi>y</mi><mn>2</mn></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{(x_1 - x_2)^2 + (y_1 - y_2)^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.24em;vertical-align:-0.30499999999999994em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.935em;"><span class="svg-align" style="top:-3.2em;"><span class="pstrut" style="height:3.2em;"></span><span class="mord" style="padding-left:1em;"><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-2.8950000000000005em;"><span class="pstrut" style="height:3.2em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.28em;"><svg width='400em' height='1.28em' viewBox='0 0 400000 1296' preserveAspectRatio='xMinYMin slice'><path d='M263,681c0.7,0,18,39.7,52,119
c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120
c340,-704.7,510.7,-1060.3,512,-1067
l0 -0
c4.7,-7.3,11,-11,19,-11
H40000v40H1012.3
s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232
c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1
s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26
c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z
M1001 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.30499999999999994em;"><span></span></span></span></span></span></span></span></span>. You can use <code>Math.Sqrt</code> static method to compute the square root of a number.</p>
<h2 id="exercise-3">Exercise 3</h2>
<p>A <code>Blob</code> is defined by a <code>Position</code> of type <code>Point2D</code> and a <code>Size</code> of type <code>int</code>. Each <code>Blob</code> randomly roams around a 100x100 area. This means that the minimum x coordinate of <code>Position</code> can be -50.0 and the maximum 50.0. The same applies for the y coordinate. Represent a <code>Blob</code> as a record with a constructor that takes no arguments and sets the position to a random <code>Point2D</code> and the speed to a random value between 1 and 5. You can use the method <code>Next(x,y)</code> in <code>Random</code> to generate an integer between <code>x</code> included and <code>y</code> excluded. For instance, if you want a number between 10 and 20 you have to call <code>r.Next(10,21)</code>, where <code>r</code> is the binding containing the instance of <code>Random</code>.</p>
<h2 id="exercise-4">Exercise 4</h2>
<p>Extend the <code>Blob</code> record by adding a method <code>Move</code> that takes no arguments and randomly moves the <code>Blob</code>. A <code>Blob</code> randomly choose whether to go up, down, left, or right, thus you can generate a random number between 0 and 3 to decide what to do and change the position accordingly. The movement must not take the <code>Blob</code> outside the 100x100 area, thus if either the x or the y coordinates are outside the interval <code>[-50,50]</code> they are reset to the lower bound or the upper bound, depending on where the overflow occurs (if you get past 50 you go back to 50, and if you go below -50 you go back to -50).</p>
<h2 id="exercise-5">Exercise 5</h2>
<p>Create a record <code>World</code> that contains two blobs and a field <code>Tick</code>. <code>World</code> contains a constructor, which takes a number of ticks and creates two blobs, and a method <code>Run</code> that takes no parameters and move the blobs around for as many ticks as specified by <code>World</code>.</p>

    </body>
    </html>